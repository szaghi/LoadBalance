module Data_Type_Block
!-----------------------------------------------------------------------------------------------------------------------------------
USE IR_Precision
USE Data_Type_SL_List
USE Lib_IO_Misc
!-----------------------------------------------------------------------------------------------------------------------------------

!-----------------------------------------------------------------------------------------------------------------------------------
implicit none
private
!-----------------------------------------------------------------------------------------------------------------------------------

!-----------------------------------------------------------------------------------------------------------------------------------
type, public:: Type_Block
  !< Definition of block data structure.
  !<
  !< It is a tree: each ancestor block could have children that are generated by the splitting of ancestor block itself.
  ! block indexes
  integer(I4P)::                  a=0  !< Index of ancestor block.
  integer(I4P)::                  l=0  !< Level of splitting.
  integer(I4P)::                  ba=0 !< Absolute block index.
  integer(I4P), allocatable::     b(:) !< Blocks map, history of splitting [1:Nl].
  integer(I4P)::                  p=-1 !< Processor assigned to.
  integer(I4P)::                  g=0  !< Index of gruop.
  integer(I4P)::                  c=0  !< Index of body.
  character(len=:), allocatable:: gt   !< Eventual group tag.
  ! block data
  integer(I4P)::              Ni=0,Nj=0,Nk=0       !< Number of cells along each directions.
  integer(I4P), allocatable:: pfi(:),pfj(:),pfk(:) !< Prime factors of Ni, Nj and Nk.
  integer(I8P)::              Wb=0                 !< Work load of each block.
  ! children blocks
  logical::                   spt=.false.   !< Flag for checking if the block is split.
  integer(I4P)::              dir=0         !< Direction of split.
  integer(I4P)::              Ns=0          !< Number of split (children) blocks.
  integer(I4P)::              Nijk=0        !< Index of cell where split happens.
  type(Type_Block), pointer:: bs(:)=>null() !< Split (children) blocks [1:Ns].
  ! leafs list
  type(Type_Block), pointer:: bnl=>null() !< Next element in the leafs list.
  type(Type_Block), pointer:: bpl=>null() !< Previous element in the leafs list.
  contains
    procedure:: init => init_block                     ! Procedure for initializing block data.
    procedure:: set => set_block                       ! Procedure for setting block data.
    procedure:: rm_from_leaf => remove_block_from_leaf ! Procedure for removing block from leafs list.
    procedure:: split => split_block                   ! Procedure for splitting block.
    procedure:: mgl_check => mgl_check_block           ! Procedure for checking multigrid levels (> mgl).
    procedure:: get_Nbs => get_block_Nbs               ! Procedure for computing the number of (split) sub-blocks.
    procedure:: get_lmax => get_block_lmax             ! Procedure for computing the maximum level of splits.
    procedure:: print => print_block                   ! Procedure for printing information of block.
    procedure:: save => save_block                     ! Procedure for saving block splitting history.
endtype Type_Block
!-----------------------------------------------------------------------------------------------------------------------------------
contains
  subroutine prime(n,p)
  !---------------------------------------------------------------------------------------------------------------------------------
  !< Compute prime factors of input integer number.
  !<
  !< The results is an array of integers containing the prime factors list.
  !---------------------------------------------------------------------------------------------------------------------------------
  implicit none
  integer(I4P),              intent(IN)::  n    !< Input number of which prime factors must be computed.
  integer(I4P), allocatable, intent(OUT):: p(:) !< Prime factors of n.
  type(Type_SL_List)::                     pl   !< Prime factors list.
  integer(I4P)::                           nn   !< Copy of Input number.
  integer(I4P)::                           d    !< Divisor.
  !---------------------------------------------------------------------------------------------------------------------------------

  !---------------------------------------------------------------------------------------------------------------------------------
  if (n==1) then
    allocate(p(1:1)) ; p = 1
    return
  endif
  nn=n
  do ! removing all factors of 2
    if (mod(nn,2_I4P)/=0.OR.nn==1) exit
    nn = nn/2_I4P
    call pl%putt(d=2_I4P)
  enddo
  d=3
  do ! removing factor 3, 5, 7, ...
    if (d>nn) exit ! if a factor is too large, exit and done
    do
      if (mod(nn,d)/=0.OR.nn==1) exit
      nn = nn/d ! remove this factor from n
      call pl%putt(d=d)
    enddo
    d = d + 2_I4P ! move to next odd number
  enddo
  call pl%array(p)
  call pl%free()
  return
  !---------------------------------------------------------------------------------------------------------------------------------
  endsubroutine prime

  elemental function div2(n) result(d2)
  !---------------------------------------------------------------------------------------------------------------------------------
  !< Compute how many times an integer is divisible for 2.
  !---------------------------------------------------------------------------------------------------------------------------------

  !---------------------------------------------------------------------------------------------------------------------------------
  implicit none
  integer(I4P), intent(IN):: n  ! Input integer.
  integer(I4P)::             d2 ! Number of times n is divisible for 2; is -1 for n=0.
  !---------------------------------------------------------------------------------------------------------------------------------

  !---------------------------------------------------------------------------------------------------------------------------------
  if (n==0) then
    d2 = -1
    return
  endif
  do d2 = 0_I4P,int(bit_size(n),I4P)-1_I4P
    if (btest(n,d2)) return
  enddo
  return
  !---------------------------------------------------------------------------------------------------------------------------------
  endfunction div2

  subroutine init_block(block)
  !---------------------------------------------------------------------------------------------------------------------------------
  !< Initialize block data.
  !---------------------------------------------------------------------------------------------------------------------------------
  implicit none
  class(Type_Block), target, intent(INOUT):: block !< Block.
  !---------------------------------------------------------------------------------------------------------------------------------

  !---------------------------------------------------------------------------------------------------------------------------------
  block%a=0
  block%l=0
  block%ba=0
  if (allocated(block%b)) deallocate(block%b)
  block%p=-1
  block%g=0
  block%c=0
  if (allocated(block%gt)) deallocate(block%gt)
  block%Ni=0 ; block%Nj=0 ; block%Nk=0
  if (allocated(block%pfi)) deallocate(block%pfi)
  if (allocated(block%pfj)) deallocate(block%pfj)
  if (allocated(block%pfk)) deallocate(block%pfk)
  block%Wb=0
  block%spt=.false.
  block%dir=0
  block%Ns=0
  block%Nijk=0
  if (associated(block%bs)) deallocate(block%bs) ; block%bs => null()
  block%bnl=>null()
  block%bpl=>null()
  return
  !---------------------------------------------------------------------------------------------------------------------------------
  endsubroutine init_block

  subroutine set_block(block,a,l,ba,b,p,g,c,gt,Ni,Nj,Nk,spt,dir,Ns,Nijk,bs,bnl,bpl,leaf)
  !---------------------------------------------------------------------------------------------------------------------------------
  !< Set block data.
  !---------------------------------------------------------------------------------------------------------------------------------
  implicit none
  class(Type_Block),          target,  intent(INOUT):: block    !< Block.
  integer(I4P),     optional,          intent(IN)::    a        !< Index of ancestor block.
  integer(I4P),     optional,          intent(IN)::    l        !< Level of splitting.
  integer(I4P),     optional,          intent(IN)::    ba       !< Absolute block index.
  integer(I4P),     optional,          intent(IN)::    b(:)     !< Blocks map, history of splitting [1:l].
  integer(I4P),     optional,          intent(IN)::    p        !< Processor assigned to.
  integer(I4P),     optional,          intent(IN)::    g        !< Index of group.
  integer(I4P),     optional,          intent(IN)::    c        !< Index of body.
  character(*),     optional,          intent(IN)::    gt       !< Group tag.
  integer(I4P),     optional,          intent(IN)::    Ni,Nj,Nk !< Number of cells along each directions.
  logical,          optional,          intent(IN)::    spt      !< Flag for checking if the block is split.
  integer(I4P),     optional,          intent(IN)::    dir      !< Direction of split.
  integer(I4P),     optional,          intent(IN)::    Ns       !< Number of split (children) blocks.
  integer(I4P),     optional,          intent(IN)::    Nijk     !< Index of cell where split happens.
  type(Type_Block), optional, pointer, intent(IN)::    bs(:)    !< Split (children) blocks [1:Ns].
  type(Type_Block), optional, pointer, intent(IN)::    bnl      !< Next element in the leafs list.
  type(Type_Block), optional, pointer, intent(IN)::    bpl      !< Previous element in the leafs list.
  type(Type_Block), optional, pointer, intent(INOUT):: leaf     !< Leafs list.
  type(Type_Block),           pointer::                cur,last !< Pointers for scanning leafs list.
  !---------------------------------------------------------------------------------------------------------------------------------

  !---------------------------------------------------------------------------------------------------------------------------------
  ! setting the passed data
  if (present(a)) block%a = a
  if (present(l)) block%l = l
  if (present(ba)) then
    block%ba = ba
  else
    block%ba = block%a
  endif
  if (present(b)) then
    if (allocated(block%b)) deallocate(block%b) ; allocate(block%b(1:size(b,dim=1))) ; block%b = b
  endif
  if (present(p)) block%p = p
  if (present(g)) block%g = g
  if (present(c)) block%c = c
  if (present(gt)) block%gt = gt
  if (present(Ni)) block%Ni = Ni
  if (present(Nj)) block%Nj = Nj
  if (present(Nk)) block%Nk = Nk
  call prime(n=block%Ni,p=block%pfi)
  call prime(n=block%Nj,p=block%pfj)
  call prime(n=block%Nk,p=block%pfk)
  block%Wb = block%Ni*block%Nj*block%Nk
  if (present(dir)) block%dir = dir
  if (present(spt)) block%spt = spt
  if (present(Ns)) block%Ns = Ns
  if (present(Nijk)) block%Nijk = Nijk
  if (present(bs)) block%bs => bs
  if (present(bnl)) block%bnl => bnl
  if (present(bpl)) block%bpl => bpl
  ! updating the leafs list
  if (present(leaf)) then
    if (block%Wb > leaf%Wb) then ! current block is heavier than the first (previous heaviest) element of the list
      block%bnl => leaf
      leaf%bpl  => block
      leaf      => block
      block%bpl => null()
    else ! scanning the leafs list for finding the position of the current block
      cur => leaf%bnl
      leaf_insert: do while(associated(cur))
        if (block%Wb > cur%Wb) then ! position found
          cur%bpl%bnl => block
          block%bnl   => cur
          block%bpl   => cur%bpl
          cur%bpl     => block
          return ! exit the subroutine
        endif
        last => cur
        cur  => cur%bnl
      enddo leaf_insert
      ! current block is the smallest and must be placed at the tail of leafs list
      last%bnl => block
      block%bpl => last
      block%bnl => null()
    endif
  endif
  return
  !---------------------------------------------------------------------------------------------------------------------------------
  endsubroutine set_block

  subroutine remove_block_from_leaf(block,leaf)
  !---------------------------------------------------------------------------------------------------------------------------------
  !< Remove block from leafs list.
  !---------------------------------------------------------------------------------------------------------------------------------
  implicit none
  class(Type_Block), target, intent(INOUT):: block !< Block.
  type(Type_Block), pointer, intent(INOUT):: leaf  !< Leafs list.
  !---------------------------------------------------------------------------------------------------------------------------------

  !---------------------------------------------------------------------------------------------------------------------------------
  if (associated(block%bpl)) then
    block%bpl%bnl => block%bnl
  else
    leaf => block%bnl
  endif
  if(associated(block%bnl)) block%bnl%bpl => block%bpl
  block%bnl => null()
  block%bpl => null()
  return
  !---------------------------------------------------------------------------------------------------------------------------------
  endsubroutine remove_block_from_leaf

  subroutine split_block(block,split_performed,mgl,leaf)
  !---------------------------------------------------------------------------------------------------------------------------------
  !< Split block.
  !<
  !< The split is done along the direction (i,j,k) with highest number of cells.
  !< @note The split is binary.
  !---------------------------------------------------------------------------------------------------------------------------------
  implicit none
  class(Type_Block),         intent(INOUT):: block                   !< Block.
  logical,      optional,    intent(OUT)::   split_performed         !< Flag for checking is the split is performed or not.
  integer(I4P),              intent(IN)::    mgl                     !< Number of levels of multi-grid to be preserved.
  type(Type_Block), pointer, intent(INOUT):: leaf                    !< Leafs list.
  type(Type_Block), pointer::                cur                     !< Pointer for scanning leafs list.
  integer(I4P)::                             dir(1:3)                !< Direction selection variable.
  integer(I4P)::                             Ni(1:2),Nj(1:2),Nk(1:2) !< Direction selection variable.
  integer(I4P)::                             b(1:block%l+1)          !< Blocks map, history of splitting.
  integer(I4P)::                             s,d                     !< Counters.
  !---------------------------------------------------------------------------------------------------------------------------------

  !---------------------------------------------------------------------------------------------------------------------------------
  if (block%spt) then
    write(stderr,'(A)')' Error: trying to split a block alredy split!'
    write(stderr,'(A)')' Block ancestor:'//trim(str(.true.,block%a))//' level:'//trim(str(.true.,block%l))
    stop
  else ! the block is a leaf and can be split
    if (present(split_performed)) split_performed = .false.
    b(1:block%l) = block%b
    dir = get_dirs(Ni=block%Ni,Nj=block%Nj,Nk=block%Nk)
    direction: do d=1,3
      select case(dir(d))
      case(1)
        if (block%Ni/2**(mgl)<2) cycle direction ! not enough MG levels
        !if (div2(block%Ni)+1<mgl) cycle direction ! not enough MG levels
        if (present(split_performed)) split_performed = .true.
        block%spt=.true. ; block%dir=dir(d) ; block%Ns=2
        allocate(block%bs(1:block%Ns))
        call block%rm_from_leaf(leaf=leaf)
        !Ni(1) = block%Ni/block%Ns ; Ni(2) = block%Ni-Ni(1)
        Ni(1) = (((block%Ni)/2**mgl)/2)*(2**mgl) ; Ni(2) = block%Ni-Ni(1)
        Nj = block%Nj
        Nk = block%Nk
        block%Nijk = Ni(1)
        do s=1,block%Ns
          b(block%l+1) = s
          call block%bs(s)%set(a=block%a,g=block%g,c=block%c,gt=block%gt,l=block%l+1,ba=block%ba+s-1,b=b,dir=block%dir,&
                               Ni=Ni(s),Nj=Nj(s),Nk=Nk(s),leaf=leaf)
        enddo
        ! performing the shift of block%ba
        cur => leaf
        do while(associated(cur))
          if (cur%ba >= block%bs(2)%ba.and.(.not. associated(cur,block%bs(2)))) cur%ba = cur%ba + 1
          cur => cur%bnl
        enddo
        exit direction
      case(2)
        if (block%Nj/2**(mgl)<2) cycle direction ! not enough MG levels
        !if (div2(block%Nj)+1<mgl) cycle direction ! not enough MG levels
        if (present(split_performed)) split_performed = .true.
        block%spt=.true. ; block%dir=dir(d) ; block%Ns=2
        allocate(block%bs(1:block%Ns))
        call block%rm_from_leaf(leaf=leaf)
        Ni = block%Ni
        Nj(1) = (((block%Nj)/2**mgl)/2)*(2**mgl) ; Nj(2) = block%Nj-Nj(1)
        Nk = block%Nk
        block%Nijk = Nj(1)
        !Nj(1) = block%Nj/block%Ns ; Nj(2) = block%Nj-Nj(1)
        !Ni = block%Ni             ; Nk = block%Nk
        do s=1,block%Ns
          b(block%l+1) = s
          call block%bs(s)%set(a=block%a,g=block%g,c=block%c,gt=block%gt,l=block%l+1,ba=block%ba+s-1,b=b,dir=block%dir,&
                               Ni=Ni(s),Nj=Nj(s),Nk=Nk(s),leaf=leaf)
        enddo
        ! performing the shift of block%ba
        cur => leaf
        do while(associated(cur))
          if (cur%ba >= block%bs(2)%ba.and.(.not. associated(cur,block%bs(2)))) cur%ba = cur%ba + 1
          cur => cur%bnl
        enddo
        exit direction
      case(3)
        if (block%Nk/2**(mgl)<2) cycle direction ! not enough MG levels
        !if (div2(block%Nk)+1<mgl) cycle direction ! not enough MG levels
        if (present(split_performed)) split_performed = .true.
        block%spt=.true. ; block%dir=dir(d) ; block%Ns=2
        allocate(block%bs(1:block%Ns))
        call block%rm_from_leaf(leaf=leaf)
        Ni = block%Ni
        Nj = block%Nj
        Nk(1) = (((block%Nk)/2**mgl)/2)*(2**mgl) ; Nk(2) = block%Nk-Nk(1)
        block%Nijk = Nk(1)
        !Nk(1) = block%Nk/block%Ns ; Nk(2) = block%Nk-Nk(1)
        !Ni = block%Ni             ; Nj = block%Nj
        do s=1,block%Ns
          b(block%l+1) = s
          call block%bs(s)%set(a=block%a,g=block%g,c=block%c,gt=block%gt,l=block%l+1,ba=block%ba+s-1,b=b,dir=block%dir,&
                               Ni=Ni(s),Nj=Nj(s),Nk=Nk(s),leaf=leaf)
        enddo
        ! performing the shift of block%ba
        cur => leaf
        do while(associated(cur))
          if (cur%ba >= block%bs(2)%ba.and.(.not. associated(cur,block%bs(2)))) cur%ba = cur%ba + 1
          cur => cur%bnl
        enddo
        exit direction
      endselect
    enddo direction
  endif
  return
  !---------------------------------------------------------------------------------------------------------------------------------
  contains
    !> Function for computing the list of directions ordered from the highest to the lowest.
    pure function get_dirs(Ni,Nj,Nk) result(dirs)
    !-------------------------------------------------------------------------------------------------------------------------------
    implicit none
    integer(I4P), intent(IN):: Ni,Nj,Nk  !< Number of cells along each direction.
    integer(I4P)::             dirs(1:3) !< Direction selection variable.
    integer(I4P)::             maxd,mind !< Temporary variables.
    !-------------------------------------------------------------------------------------------------------------------------------

    !-------------------------------------------------------------------------------------------------------------------------------
    maxd = maxloc([Ni,Nj,Nk],dim=1) ; mind = minloc([Ni,Nj,Nk],dim=1) ; dirs = [maxd,6-maxd-mind,mind]
    return
    !-------------------------------------------------------------------------------------------------------------------------------
    endfunction get_dirs
  endsubroutine split_block

  function mgl_check_block(block,mgl) result(check_mgl)
  !---------------------------------------------------------------------------------------------------------------------------------
  !< Check if block has enough multigrid levels.
  !---------------------------------------------------------------------------------------------------------------------------------
  implicit none
  class(Type_Block), intent(IN):: block     !< Block.
  integer(I4P),      intent(IN):: mgl       !< Number of levels of multi-grid to be checked.
  logical::                       check_mgl !< True/false if check ok.
  !---------------------------------------------------------------------------------------------------------------------------------

  !---------------------------------------------------------------------------------------------------------------------------------
  check_mgl = .true.
  if (div2(block%Ni)+1<mgl) check_mgl = .false.
  if (div2(block%Nj)+1<mgl) check_mgl = .false.
  if (div2(block%Nk)+1<mgl) check_mgl = .false.
  return
  !---------------------------------------------------------------------------------------------------------------------------------
  endfunction mgl_check_block

  recursive subroutine get_block_Nbs(block,Nbs)
  !---------------------------------------------------------------------------------------------------------------------------------
  !< Compute the number of split sub-blocks.
  !---------------------------------------------------------------------------------------------------------------------------------
  implicit none
  class(Type_Block), intent(IN)::    block !< Block data.
  integer(I4P),      intent(INOUT):: Nbs   !< Number of (split) sub-blocks.
  integer(I4P)::                     s     !< Counter.
  !---------------------------------------------------------------------------------------------------------------------------------

  !---------------------------------------------------------------------------------------------------------------------------------
  if (block%spt) then
    do s=1,block%Ns
      call get_block_Nbs(block=block%bs(s),Nbs=Nbs)
    enddo
  else
    Nbs = Nbs + 1
  endif
  return
  !---------------------------------------------------------------------------------------------------------------------------------
  endsubroutine get_block_Nbs

  recursive subroutine get_block_lmax(block,lmax)
  !---------------------------------------------------------------------------------------------------------------------------------
  !< Compute the maximum level of splitting.
  !---------------------------------------------------------------------------------------------------------------------------------
  implicit none
  class(Type_Block), intent(IN)::    block !< Block data.
  integer(I4P),      intent(INOUT):: lmax  !< Number of maximum level of splits.
  integer(I4P)::                     s     !< Counter.
  !---------------------------------------------------------------------------------------------------------------------------------

  !---------------------------------------------------------------------------------------------------------------------------------
  if (block%spt) then
    do s=1,block%Ns
      call get_block_lmax(block=block%bs(s),lmax=lmax)
    enddo
  else
    lmax = max(block%l,lmax)
  endif
  return
  !---------------------------------------------------------------------------------------------------------------------------------
  endsubroutine get_block_lmax

  subroutine print_block(block)
  !---------------------------------------------------------------------------------------------------------------------------------
  !< Print information of block.
  !---------------------------------------------------------------------------------------------------------------------------------
  implicit none
  class(Type_Block), intent(IN):: block   !< Block to be printed.
  character(1000)::               sbuffer !< String buffer.
  integer(I4P)::                  lmax    !< Maximum level of splits.
  integer(I4P)::                  p       !< Counter.
  !---------------------------------------------------------------------------------------------------------------------------------

  !---------------------------------------------------------------------------------------------------------------------------------
  lmax = 0
  call block%get_lmax(lmax=lmax)
  sbuffer='   Block:'//trim(str('(I7)',block%a))//', Work Load:'//trim(str('(I8)',block%Wb))//', Dimensions: '
  sbuffer=trim(sbuffer)//' Ni '//trim(str('(I4)',block%Ni))//' PF='
  do p=1,size(block%pfi)-1
    sbuffer=trim(sbuffer)//trim(str(.true.,block%pfi(p)))//'-'
  enddo
  sbuffer=trim(sbuffer)//trim(str(.true.,block%pfi(size(block%pfi))))
  sbuffer=trim(sbuffer)//', Nj '//trim(str('(I4)',block%Nj))//' PF='
  do p=1,size(block%pfj)-1
    sbuffer=trim(sbuffer)//trim(str(.true.,block%pfj(p)))//'-'
  enddo
  sbuffer=trim(sbuffer)//trim(str(.true.,block%pfj(size(block%pfj))))
  sbuffer=trim(sbuffer)//', Nk '//trim(str('(I4)',block%Nk))//' PF='
  do p=1,size(block%pfk)-1
    sbuffer=trim(sbuffer)//trim(str(.true.,block%pfk(p)))//'-'
  enddo
  sbuffer=trim(sbuffer)//trim(str(.true.,block%pfk(size(block%pfk))))
  sbuffer=trim(sbuffer)//', Maximum level of splits:'//trim(str('(I4)',lmax))
  write(stdout,'(A)')trim(sbuffer)
  return
  !---------------------------------------------------------------------------------------------------------------------------------
  endsubroutine print_block

  subroutine save_block(block)
  !---------------------------------------------------------------------------------------------------------------------------------
  !< Recursively save block splitting history.
  !---------------------------------------------------------------------------------------------------------------------------------
  implicit none
  class(Type_Block), intent(IN):: block   !< Block to be saved.
  integer(I4P)::                  u       !< Logical unit.
  character(1000)::               sbuffer !< String buffer.
  integer(I4P)::                  s       !< Counters.
  !---------------------------------------------------------------------------------------------------------------------------------

  !---------------------------------------------------------------------------------------------------------------------------------
  open(unit=Get_Unit(u),file='block'//trim(strz(4,block%a))//'-splits.his')
  sbuffer = trim(str(.true.,block%a))//         &
            ' Ni:'//trim(str(.true.,block%Ni))//&
            ' Nj:'//trim(str(.true.,block%Nj))//&
            ' Nk:'//trim(str(.true.,block%Nk))//&
            ' Ns:'//trim(str(.true.,block%Ns))//&
            ' dir:'//trim(str(.true.,block%dir))
  sbuffer = trim(sbuffer)//' PFi:'
  do s=1,size(block%pfi,dim=1)-1
    sbuffer = trim(sbuffer)//trim(str(.true.,block%pfi(s)))//'-'
  enddo
  sbuffer = trim(sbuffer)//trim(str(.true.,block%pfi(size(block%pfi,dim=1))))
  sbuffer = trim(sbuffer)//' PFj:'
  do s=1,size(block%pfj,dim=1)-1
    sbuffer = trim(sbuffer)//trim(str(.true.,block%pfj(s)))//'-'
  enddo
  sbuffer = trim(sbuffer)//trim(str(.true.,block%pfj(size(block%pfj,dim=1))))
  sbuffer = trim(sbuffer)//' PFk:'
  do s=1,size(block%pfk,dim=1)-1
    sbuffer = trim(sbuffer)//trim(str(.true.,block%pfk(s)))//'-'
  enddo
  sbuffer = trim(sbuffer)//trim(str(.true.,block%pfk(size(block%pfk,dim=1))))
  write(u,'(A)')trim(sbuffer)
  if (block%spt) then
    do s=1,block%Ns
      call save_sblock(sblock=block%bs(s),si=2,su=u)
    enddo
  endif
  close(u)
  return
  !---------------------------------------------------------------------------------------------------------------------------------
  contains
    recursive subroutine save_sblock(sblock,si,su)
    !-------------------------------------------------------------------------------------------------------------------------------
    implicit none
    type(Type_Block), intent(IN):: sblock !< Block to be saved.
    integer(I4P),     intent(IN):: si     !< Indenting white spaces.
    integer(I4P),     intent(IN):: su     !< Logical unit.
    integer(I4P)::                 ss     !< Counters.
    character(1000)::              sbuf   !< String buffer.
    !-------------------------------------------------------------------------------------------------------------------------------

    !-------------------------------------------------------------------------------------------------------------------------------
    sbuf = repeat(' ',si)//trim(str(.true.,sblock%a))//' L:'//trim(str(.true.,sblock%l))//&
           ' Ni:'//trim(str(.true.,sblock%Ni))//                                          &
           ' Nj:'//trim(str(.true.,sblock%Nj))//                                          &
           ' Nk:'//trim(str(.true.,sblock%Nk))//                                          &
           ' Ns:'//trim(str(.true.,sblock%Ns))//                                          &
           ' dir:'//trim(str(.true.,sblock%dir))
    sbuf = trim(sbuf)//' PFi:'
    do ss=1,size(sblock%pfi,dim=1)-1
      sbuf = trim(sbuf)//trim(str(.true.,sblock%pfi(ss)))//'-'
    enddo
    sbuf = trim(sbuf)//trim(str(.true.,sblock%pfi(size(sblock%pfi,dim=1))))
    sbuf = trim(sbuf)//' PFj:'
    do ss=1,size(sblock%pfj,dim=1)-1
      sbuf = trim(sbuf)//trim(str(.true.,sblock%pfj(ss)))//'-'
    enddo
    sbuf = trim(sbuf)//trim(str(.true.,sblock%pfj(size(sblock%pfj,dim=1))))
    sbuf = trim(sbuf)//' PFk:'
    do ss=1,size(sblock%pfk,dim=1)-1
      sbuf = trim(sbuf)//trim(str(.true.,sblock%pfk(ss)))//'-'
    enddo
    sbuf = trim(sbuf)//trim(str(.true.,sblock%pfk(size(sblock%pfk,dim=1))))
    write(su,'(A)')trim(sbuf)
    if (sblock%spt) then
      do ss=1,sblock%Ns
        call save_sblock(sblock=sblock%bs(ss),si=si+2,su=su)
      enddo
    endif
    return
    !-------------------------------------------------------------------------------------------------------------------------------
    endsubroutine save_sblock
  endsubroutine save_block
endmodule Data_Type_Block
