!> @brief Module containing derived types and procedures for performing load balancing.
!> @note The "mgl" factor should be eliminated at the beginning for efficiency.
module Lib_Balancing
!-----------------------------------------------------------------------------------------------------------------------------------
USE IR_Precision
USE Data_Type_SL_List
USE Data_Type_Time
USE Lib_IO_Misc
USE Lib_Math
!-----------------------------------------------------------------------------------------------------------------------------------

!-----------------------------------------------------------------------------------------------------------------------------------
implicit none
private
public:: Nc
public:: leaf
public:: split_block_gt_Wi
public:: split_block_leaf
public:: assign_block_leaf
public:: init_leaf
public:: converging_check
public:: save_output
!-----------------------------------------------------------------------------------------------------------------------------------

!-----------------------------------------------------------------------------------------------------------------------------------
integer(I4P), parameter:: Nc=100 !< Number of character of prototype string.
!> Definition of block data structure. It is a tree: each ancestor block could have children that are generated by the splitting of
!> ancestor block itself.
type, public:: Type_Block
  ! block indexes
  integer(I4P)::              a=0  !< Index of ancestor block.
  integer(I4P)::              l=0  !< Level of splitting.
  integer(I4P)::              ba=0 !< Absolute block index.
  integer(I4P), allocatable:: b(:) !< Blocks map, history of splitting [1:Nl].
  integer(I4P)::              p=-1 !< Processor assigned to.
  ! block data
  integer(I4P)::              Ni=0,Nj=0,Nk=0       !< Number of cells along each directions.
  integer(I4P), allocatable:: pfi(:),pfj(:),pfk(:) !< Prime factors of Ni, Nj and Nk.
  integer(I8P)::              Wb=0                 !< Work load of each block.
  ! children blocks
  logical::                   spt=.false.   !< Flag for checking if the block is split.
  integer(I4P)::              dir=0         !< Direction of split.
  integer(I4P)::              Ns=0          !< Number of split (children) blocks.
  integer(I4P)::              Nijk=0        !< Index of cell where split happens.
  type(Type_Block), pointer:: bs(:)=>null() !< Split (children) blocks [1:Ns].
  ! leafs list
  type(Type_Block), pointer:: bnl=>null() !< Next element in the leafs list.
  type(Type_Block), pointer:: bpl=>null() !< Previous element in the leafs list.
  contains
    procedure:: init => init_block                     ! Procedure for initializing block data.
    procedure:: set => set_block                       ! Procedure for setting block data.
    procedure:: rm_from_leaf => remove_block_from_leaf ! Procedure for removing block from leafs list.
    procedure:: split => split_block                   ! Procedure for splitting block.
    procedure:: mgl_check => mgl_check_block           ! Procedure for checking multigrid levels (> mgl).
    procedure:: get_Nbs => get_block_Nbs               ! Procedure for computing the number of (split) sub-blocks.
    procedure:: get_lmax => get_block_lmax             ! Procedure for computing the maximum level of splits.
    procedure:: print => print_block                   ! Procedure for printing information of block.
    procedure:: save => save_block                     ! Procedure for saving block splitting history.
endtype Type_Block
type(Type_Block), pointer:: leaf=>null() !< Leafs list.
!> Definition of processor data structure.
type, public:: Type_Proc
  ! processor data
  real(R8P)::    Wpr=0._R8P       !< Work load ratio of the processor.
  integer(I8P):: Wp=0             !< Work load of the processor.
  logical::      balanced=.false. !< Flag for checking if the processor is balanced.
  integer(I4P):: Nb=0             !< Number of blocks of the processor.
  contains
    procedure:: init => init_proc ! Procedure for initializing processor data.
    procedure:: set => set_proc   ! Procedure for setting processor data.
endtype Type_Proc
!-----------------------------------------------------------------------------------------------------------------------------------
contains
  ! type bound procedures of Type_Block
  !> @brief Subroutine for initializing block data.
  subroutine init_block(block)
  !---------------------------------------------------------------------------------------------------------------------------------
  implicit none
  class(Type_Block), target, intent(INOUT):: block !< Block.
  !---------------------------------------------------------------------------------------------------------------------------------

  !---------------------------------------------------------------------------------------------------------------------------------
  block%a=0
  block%l=0
  block%ba=0
  if (allocated(block%b)) deallocate(block%b)
  block%p=-1
  block%Ni=0 ; block%Nj=0 ; block%Nk=0
  if (allocated(block%pfi)) deallocate(block%pfi)
  if (allocated(block%pfj)) deallocate(block%pfj)
  if (allocated(block%pfk)) deallocate(block%pfk)
  block%Wb=0
  block%spt=.false.
  block%dir=0
  block%Ns=0
  block%Nijk=0
  if (associated(block%bs)) deallocate(block%bs) ; block%bs => null()
  block%bnl=>null()
  block%bpl=>null()
  return
  !---------------------------------------------------------------------------------------------------------------------------------
  endsubroutine init_block

  !> @brief Subroutine for setting block data.
  subroutine set_block(block,a,l,ba,b,p,Ni,Nj,Nk,spt,dir,Ns,Nijk,bs,bnl,bpl,leaf)
  !---------------------------------------------------------------------------------------------------------------------------------
  implicit none
  class(Type_Block),          target,  intent(INOUT):: block    !< Block.
  integer(I4P),     optional,          intent(IN)::    a        !< Index of ancestor block.
  integer(I4P),     optional,          intent(IN)::    l        !< Level of splitting.
  integer(I4P),     optional,          intent(IN)::    ba       !< Absolute block index.
  integer(I4P),     optional,          intent(IN)::    b(:)     !< Blocks map, history of splitting [1:l].
  integer(I4P),     optional,          intent(IN)::    p        !< Processor assigned to.
  integer(I4P),     optional,          intent(IN)::    Ni,Nj,Nk !< Number of cells along each directions.
  logical,          optional,          intent(IN)::    spt      !< Flag for checking if the block is split.
  integer(I4P),     optional,          intent(IN)::    dir      !< Direction of split.
  integer(I4P),     optional,          intent(IN)::    Ns       !< Number of split (children) blocks.
  integer(I4P),     optional,          intent(IN)::    Nijk     !< Index of cell where split happens.
  type(Type_Block), optional, pointer, intent(IN)::    bs(:)    !< Split (children) blocks [1:Ns].
  type(Type_Block), optional, pointer, intent(IN)::    bnl      !< Next element in the leafs list.
  type(Type_Block), optional, pointer, intent(IN)::    bpl      !< Previous element in the leafs list.
  type(Type_Block), optional, pointer, intent(INOUT):: leaf     !< Leafs list.
  type(Type_Block),           pointer::                cur,last !< Pointers for scanning leafs list.
  !---------------------------------------------------------------------------------------------------------------------------------

  !---------------------------------------------------------------------------------------------------------------------------------
  ! setting the passed data
  if (present(a)) block%a = a
  if (present(l)) block%l = l
  if (present(ba)) then
    block%ba = ba
  else
    block%ba = block%a
  endif
  if (present(b)) then
    if (allocated(block%b)) deallocate(block%b) ; allocate(block%b(1:size(b,dim=1))) ; block%b = b
  endif
  if (present(p)) block%p = p
  if (present(Ni)) block%Ni = Ni
  if (present(Nj)) block%Nj = Nj
  if (present(Nk)) block%Nk = Nk
  call prime(n=block%Ni,p=block%pfi)
  call prime(n=block%Nj,p=block%pfj)
  call prime(n=block%Nk,p=block%pfk)
  block%Wb = block%Ni*block%Nj*block%Nk
  if (present(dir)) block%dir = dir
  if (present(spt)) block%spt = spt
  if (present(Ns)) block%Ns = Ns
  if (present(Nijk)) block%Nijk = Nijk
  if (present(bs)) block%bs => bs
  if (present(bnl)) block%bnl => bnl
  if (present(bpl)) block%bpl => bpl
  ! updating the leafs list
  if (present(leaf)) then
    if (block%Wb > leaf%Wb) then ! current block is heavier than the first (previous heaviest) element of the list
      block%bnl => leaf
      leaf%bpl  => block
      leaf      => block
      block%bpl => null()
    else ! scanning the leafs list for finding the position of the current block
      cur => leaf%bnl
      leaf_insert: do while(associated(cur))
        if (block%Wb > cur%Wb) then ! position found
          cur%bpl%bnl => block
          block%bnl   => cur
          block%bpl   => cur%bpl
          cur%bpl     => block
          return ! exit the subroutine
        endif
        last => cur
        cur  => cur%bnl
      enddo leaf_insert
      ! current block is the smallest and must be placed at the tail of leafs list
      last%bnl => block
      block%bpl => last
      block%bnl => null()
    endif
  endif
  return
  !---------------------------------------------------------------------------------------------------------------------------------
  endsubroutine set_block

  !> @brief Subroutine for removing block from leafs list.
  subroutine remove_block_from_leaf(block,leaf)
  !---------------------------------------------------------------------------------------------------------------------------------
  implicit none
  class(Type_Block), target, intent(INOUT):: block !< Block.
  type(Type_Block), pointer, intent(INOUT):: leaf  !< Leafs list.
  !---------------------------------------------------------------------------------------------------------------------------------

  !---------------------------------------------------------------------------------------------------------------------------------
  if (associated(block%bpl)) then
    block%bpl%bnl => block%bnl
  else
    leaf => block%bnl
  endif
  if(associated(block%bnl)) block%bnl%bpl => block%bpl
  block%bnl => null()
  block%bpl => null()
  return
  !---------------------------------------------------------------------------------------------------------------------------------
  endsubroutine remove_block_from_leaf

  !> @brief Subroutine for splitting block. The split is done along the direction (i,j,k) with highest number of cells.
  !> The split is binary.
  subroutine split_block(block,split_performed,mgl,leaf)
  !---------------------------------------------------------------------------------------------------------------------------------
  implicit none
  class(Type_Block),         intent(INOUT):: block                   !< Block.
  logical,      optional,    intent(OUT)::   split_performed         !< Flag for checking is the split is performed or not.
  integer(I4P),              intent(IN)::    mgl                     !< Number of levels of multi-grid to be preserved.
  type(Type_Block), pointer, intent(INOUT):: leaf                    !< Leafs list.
  type(Type_Block), pointer::                cur                     !< Pointer for scanning leafs list.
  integer(I4P)::                             dir(1:3)                !< Direction selection variable.
  integer(I4P)::                             Ni(1:2),Nj(1:2),Nk(1:2) !< Direction selection variable.
  integer(I4P)::                             b(1:block%l+1)          !< Blocks map, history of splitting.
  integer(I4P)::                             s,d                     !< Counters.
  !---------------------------------------------------------------------------------------------------------------------------------

  !---------------------------------------------------------------------------------------------------------------------------------
  if (block%spt) then
    write(stderr,'(A)')' Error: trying to split a block alredy split!'
    write(stderr,'(A)')' Block ancestor:'//trim(str(.true.,block%a))//' level:'//trim(str(.true.,block%l))
    stop
  else ! the block is a leaf and can be split
    if (present(split_performed)) split_performed = .false.
    b(1:block%l) = block%b
    dir = get_dirs(Ni=block%Ni,Nj=block%Nj,Nk=block%Nk)
    direction: do d=1,3
      select case(dir(d))
      case(1)
        if (block%Ni/2**(mgl)<2) cycle direction ! not enough MG levels
        !if (div2(block%Ni)+1<mgl) cycle direction ! not enough MG levels
        if (present(split_performed)) split_performed = .true.
        block%spt=.true. ; block%dir=dir(d) ; block%Ns=2
        allocate(block%bs(1:block%Ns))
        call block%rm_from_leaf(leaf=leaf)
        !Ni(1) = block%Ni/block%Ns ; Ni(2) = block%Ni-Ni(1)
        Ni(1) = (((block%Ni)/2**mgl)/2)*(2**mgl) ; Ni(2) = block%Ni-Ni(1)
        Nj = block%Nj
        Nk = block%Nk
        block%Nijk = Ni(1)
        do s=1,block%Ns
          b(block%l+1) = s
          call block%bs(s)%set(a=block%a,l=block%l+1,ba=block%ba+s-1,b=b,dir=block%dir,Ni=Ni(s),Nj=Nj(s),Nk=Nk(s),leaf=leaf)
        enddo
        ! performing the shift of block%ba
        cur => leaf
        do while(associated(cur))
          if (cur%ba >= block%bs(2)%ba.and.(.not. associated(cur,block%bs(2)))) cur%ba = cur%ba + 1
          cur => cur%bnl
        enddo
        exit direction
      case(2)
        if (block%Nj/2**(mgl)<2) cycle direction ! not enough MG levels
        !if (div2(block%Nj)+1<mgl) cycle direction ! not enough MG levels
        if (present(split_performed)) split_performed = .true.
        block%spt=.true. ; block%dir=dir(d) ; block%Ns=2
        allocate(block%bs(1:block%Ns))
        call block%rm_from_leaf(leaf=leaf)
        Ni = block%Ni
        Nj(1) = (((block%Nj)/2**mgl)/2)*(2**mgl) ; Nj(2) = block%Nj-Nj(1)
        Nk = block%Nk
        block%Nijk = Nj(1)
        !Nj(1) = block%Nj/block%Ns ; Nj(2) = block%Nj-Nj(1)
        !Ni = block%Ni             ; Nk = block%Nk
        do s=1,block%Ns
          b(block%l+1) = s
          call block%bs(s)%set(a=block%a,l=block%l+1,ba=block%ba+s-1,b=b,dir=block%dir,Ni=Ni(s),Nj=Nj(s),Nk=Nk(s),leaf=leaf)
        enddo
        ! performing the shift of block%ba
        cur => leaf
        do while(associated(cur))
          if (cur%ba >= block%bs(2)%ba.and.(.not. associated(cur,block%bs(2)))) cur%ba = cur%ba + 1
          cur => cur%bnl
        enddo
        exit direction
      case(3)
        if (block%Nk/2**(mgl)<2) cycle direction ! not enough MG levels
        !if (div2(block%Nk)+1<mgl) cycle direction ! not enough MG levels
        if (present(split_performed)) split_performed = .true.
        block%spt=.true. ; block%dir=dir(d) ; block%Ns=2
        allocate(block%bs(1:block%Ns))
        call block%rm_from_leaf(leaf=leaf)
        Ni = block%Ni
        Nj = block%Nj
        Nk(1) = (((block%Nk)/2**mgl)/2)*(2**mgl) ; Nk(2) = block%Nk-Nk(1)
        block%Nijk = Nk(1)
        !Nk(1) = block%Nk/block%Ns ; Nk(2) = block%Nk-Nk(1)
        !Ni = block%Ni             ; Nj = block%Nj
        do s=1,block%Ns
          b(block%l+1) = s
          call block%bs(s)%set(a=block%a,l=block%l+1,ba=block%ba+s-1,b=b,dir=block%dir,Ni=Ni(s),Nj=Nj(s),Nk=Nk(s),leaf=leaf)
        enddo
        ! performing the shift of block%ba
        cur => leaf
        do while(associated(cur))
          if (cur%ba >= block%bs(2)%ba.and.(.not. associated(cur,block%bs(2)))) cur%ba = cur%ba + 1
          cur => cur%bnl
        enddo
        exit direction
      endselect
    enddo direction
  endif
  return
  !---------------------------------------------------------------------------------------------------------------------------------
  contains
    !> Function for computing the list of directions ordered from the highest to the lowest.
    pure function get_dirs(Ni,Nj,Nk) result(dirs)
    !-------------------------------------------------------------------------------------------------------------------------------
    implicit none
    integer(I4P), intent(IN):: Ni,Nj,Nk  !< Number of cells along each direction.
    integer(I4P)::             dirs(1:3) !< Direction selection variable.
    integer(I4P)::             maxd,mind !< Temporary variables.
    !-------------------------------------------------------------------------------------------------------------------------------

    !-------------------------------------------------------------------------------------------------------------------------------
    maxd = maxloc([Ni,Nj,Nk],dim=1) ; mind = minloc([Ni,Nj,Nk],dim=1) ; dirs = [maxd,6-maxd-mind,mind]
    return
    !-------------------------------------------------------------------------------------------------------------------------------
    endfunction get_dirs
  endsubroutine split_block

  !> @brief Subroutine for checking if block has enough multigrid levels.
  function mgl_check_block(block,mgl) result(check_mgl)
  !---------------------------------------------------------------------------------------------------------------------------------
  implicit none
  class(Type_Block), intent(IN):: block     !< Block.
  integer(I4P),      intent(IN):: mgl       !< Number of levels of multi-grid to be checked.
  logical::                       check_mgl !< True/false if check ok.
  !---------------------------------------------------------------------------------------------------------------------------------

  !---------------------------------------------------------------------------------------------------------------------------------
  check_mgl = .true.
  if (div2(block%Ni)+1<mgl) check_mgl = .false.
  if (div2(block%Nj)+1<mgl) check_mgl = .false.
  if (div2(block%Nk)+1<mgl) check_mgl = .false.
  return
  !---------------------------------------------------------------------------------------------------------------------------------
  endfunction mgl_check_block

  !> @brief Subroutine for computing the number of split sub-blocks.
  recursive subroutine get_block_Nbs(block,Nbs)
  !---------------------------------------------------------------------------------------------------------------------------------
  implicit none
  class(Type_Block), intent(IN)::    block !< Block data.
  integer(I4P),      intent(INOUT):: Nbs   !< Number of (split) sub-blocks.
  integer(I4P)::                     s     !< Counter.
  !---------------------------------------------------------------------------------------------------------------------------------

  !---------------------------------------------------------------------------------------------------------------------------------
  if (block%spt) then
    do s=1,block%Ns
      call get_block_Nbs(block=block%bs(s),Nbs=Nbs)
    enddo
  else
    Nbs = Nbs + 1
  endif
  return
  !---------------------------------------------------------------------------------------------------------------------------------
  endsubroutine get_block_Nbs

  !> @brief Subroutine for computing the maximum level of splitting.
  recursive subroutine get_block_lmax(block,lmax)
  !---------------------------------------------------------------------------------------------------------------------------------
  implicit none
  class(Type_Block), intent(IN)::    block !< Block data.
  integer(I4P),      intent(INOUT):: lmax  !< Number of maximum level of splits.
  integer(I4P)::                     s     !< Counter.
  !---------------------------------------------------------------------------------------------------------------------------------

  !---------------------------------------------------------------------------------------------------------------------------------
  if (block%spt) then
    do s=1,block%Ns
      call get_block_lmax(block=block%bs(s),lmax=lmax)
    enddo
  else
    lmax = max(block%l,lmax)
  endif
  return
  !---------------------------------------------------------------------------------------------------------------------------------
  endsubroutine get_block_lmax

  !> @brief Subroutine for printing information of block.
  subroutine print_block(block)
  !---------------------------------------------------------------------------------------------------------------------------------
  implicit none
  class(Type_Block), intent(IN):: block   !< Block to be printed.
  character(1000)::               sbuffer !< String buffer.
  integer(I4P)::                  lmax    !< Maximum level of splits.
  integer(I4P)::                  p       !< Counter.
  !---------------------------------------------------------------------------------------------------------------------------------

  !---------------------------------------------------------------------------------------------------------------------------------
  lmax = 0
  call block%get_lmax(lmax=lmax)
  sbuffer='   Block:'//trim(str('(I7)',block%a))//', Work Load:'//trim(str('(I8)',block%Wb))//', Dimensions: '
  sbuffer=trim(sbuffer)//' Ni '//trim(str('(I4)',block%Ni))//' PF='
  do p=1,size(block%pfi)-1
    sbuffer=trim(sbuffer)//trim(str(.true.,block%pfi(p)))//'-'
  enddo
  sbuffer=trim(sbuffer)//trim(str(.true.,block%pfi(size(block%pfi))))
  sbuffer=trim(sbuffer)//', Nj '//trim(str('(I4)',block%Nj))//' PF='
  do p=1,size(block%pfj)-1
    sbuffer=trim(sbuffer)//trim(str(.true.,block%pfj(p)))//'-'
  enddo
  sbuffer=trim(sbuffer)//trim(str(.true.,block%pfj(size(block%pfj))))
  sbuffer=trim(sbuffer)//', Nk '//trim(str('(I4)',block%Nk))//' PF='
  do p=1,size(block%pfk)-1
    sbuffer=trim(sbuffer)//trim(str(.true.,block%pfk(p)))//'-'
  enddo
  sbuffer=trim(sbuffer)//trim(str(.true.,block%pfk(size(block%pfk))))
  sbuffer=trim(sbuffer)//', Maximum level of splits:'//trim(str('(I4)',lmax))
  write(stdout,'(A)')trim(sbuffer)
  return
  !---------------------------------------------------------------------------------------------------------------------------------
  endsubroutine print_block

  !> @brief Subroutine for recursively saving block splitting history.
  subroutine save_block(block)
  !---------------------------------------------------------------------------------------------------------------------------------
  implicit none
  class(Type_Block), intent(IN):: block   !< Block to be saved.
  integer(I4P)::                  u       !< Logical unit.
  character(1000)::               sbuffer !< String buffer.
  integer(I4P)::                  s       !< Counters.
  !---------------------------------------------------------------------------------------------------------------------------------

  !---------------------------------------------------------------------------------------------------------------------------------
  open(unit=Get_Unit(u),file='block'//trim(strz(4,block%a))//'-splits.his')
  sbuffer = trim(str(.true.,block%a))//         &
            ' Ni:'//trim(str(.true.,block%Ni))//&
            ' Nj:'//trim(str(.true.,block%Nj))//&
            ' Nk:'//trim(str(.true.,block%Nk))//&
            ' Ns:'//trim(str(.true.,block%Ns))//&
            ' dir:'//trim(str(.true.,block%dir))
  sbuffer = trim(sbuffer)//' PFi:'
  do s=1,size(block%pfi,dim=1)-1
    sbuffer = trim(sbuffer)//trim(str(.true.,block%pfi(s)))//'-'
  enddo
  sbuffer = trim(sbuffer)//trim(str(.true.,block%pfi(size(block%pfi,dim=1))))
  sbuffer = trim(sbuffer)//' PFj:'
  do s=1,size(block%pfj,dim=1)-1
    sbuffer = trim(sbuffer)//trim(str(.true.,block%pfj(s)))//'-'
  enddo
  sbuffer = trim(sbuffer)//trim(str(.true.,block%pfj(size(block%pfj,dim=1))))
  sbuffer = trim(sbuffer)//' PFk:'
  do s=1,size(block%pfk,dim=1)-1
    sbuffer = trim(sbuffer)//trim(str(.true.,block%pfk(s)))//'-'
  enddo
  sbuffer = trim(sbuffer)//trim(str(.true.,block%pfk(size(block%pfk,dim=1))))
  write(u,'(A)')trim(sbuffer)
  if (block%spt) then
    do s=1,block%Ns
      call save_sblock(sblock=block%bs(s),si=2,su=u)
    enddo
  endif
  close(u)
  return
  !---------------------------------------------------------------------------------------------------------------------------------
  contains
    recursive subroutine save_sblock(sblock,si,su)
    !-------------------------------------------------------------------------------------------------------------------------------
    implicit none
    type(Type_Block), intent(IN):: sblock !< Block to be saved.
    integer(I4P),     intent(IN):: si     !< Indenting white spaces.
    integer(I4P),     intent(IN):: su     !< Logical unit.
    integer(I4P)::                 ss     !< Counters.
    character(1000)::              sbuf   !< String buffer.
    !-------------------------------------------------------------------------------------------------------------------------------

    !-------------------------------------------------------------------------------------------------------------------------------
    sbuf = repeat(' ',si)//trim(str(.true.,sblock%a))//' L:'//trim(str(.true.,sblock%l))//&
           ' Ni:'//trim(str(.true.,sblock%Ni))//                                          &
           ' Nj:'//trim(str(.true.,sblock%Nj))//                                          &
           ' Nk:'//trim(str(.true.,sblock%Nk))//                                          &
           ' Ns:'//trim(str(.true.,sblock%Ns))//                                          &
           ' dir:'//trim(str(.true.,sblock%dir))
    sbuf = trim(sbuf)//' PFi:'
    do ss=1,size(sblock%pfi,dim=1)-1
      sbuf = trim(sbuf)//trim(str(.true.,sblock%pfi(ss)))//'-'
    enddo
    sbuf = trim(sbuf)//trim(str(.true.,sblock%pfi(size(sblock%pfi,dim=1))))
    sbuf = trim(sbuf)//' PFj:'
    do ss=1,size(sblock%pfj,dim=1)-1
      sbuf = trim(sbuf)//trim(str(.true.,sblock%pfj(ss)))//'-'
    enddo
    sbuf = trim(sbuf)//trim(str(.true.,sblock%pfj(size(sblock%pfj,dim=1))))
    sbuf = trim(sbuf)//' PFk:'
    do ss=1,size(sblock%pfk,dim=1)-1
      sbuf = trim(sbuf)//trim(str(.true.,sblock%pfk(ss)))//'-'
    enddo
    sbuf = trim(sbuf)//trim(str(.true.,sblock%pfk(size(sblock%pfk,dim=1))))
    write(su,'(A)')trim(sbuf)
    if (sblock%spt) then
      do ss=1,sblock%Ns
        call save_sblock(sblock=sblock%bs(ss),si=si+2,su=su)
      enddo
    endif
    return
    !-------------------------------------------------------------------------------------------------------------------------------
    endsubroutine save_sblock
  endsubroutine save_block

  ! type bound procedures of Type_Proc
  !> @brief Subroutine for initializing processor data.
  subroutine init_proc(proc)
  !---------------------------------------------------------------------------------------------------------------------------------
  implicit none
  class(Type_Proc), intent(INOUT):: proc !< Processor (self) data.
  !---------------------------------------------------------------------------------------------------------------------------------

  !---------------------------------------------------------------------------------------------------------------------------------
  proc%Wpr = 0._R8P
  proc%Wp = 0
  proc%balanced = .false.
  proc%Nb = 0
  return
  !---------------------------------------------------------------------------------------------------------------------------------
  endsubroutine init_proc

  !> @brief Subroutine for setting processor data.
  subroutine set_proc(proc,Wpr,Wp,balanced,Nb)
  !---------------------------------------------------------------------------------------------------------------------------------
  implicit none
  class(Type_Proc),             intent(INOUT):: proc       !< Processor (self) data.
  real(R8P),          optional, intent(IN)::    Wpr        !< Work load ratio of the processor.
  integer(I8P),       optional, intent(IN)::    Wp         !< Work load of the processor.
  logical,            optional, intent(IN)::    balanced   !< Flag for checking if the processor is balanced.
  integer(I4P),       optional, intent(IN)::    Nb         !< Number of blocks of the processor.
  !---------------------------------------------------------------------------------------------------------------------------------

  !---------------------------------------------------------------------------------------------------------------------------------
  if (present(Wpr)) proc%Wpr = Wpr
  if (present(Wp)) proc%Wp = Wp
  if (present(balanced)) proc%balanced = balanced
  if (present(Nb)) proc%Nb = Nb
  return
  !---------------------------------------------------------------------------------------------------------------------------------
  endsubroutine set_proc

  ! non type bound procedures
  !> @brief Function for computing the lenght of a Type_Block linked list.
  function len_list(l) result(leng)
  !---------------------------------------------------------------------------------------------------------------------------------
  implicit none
  type(Type_Block), pointer, intent(INOUT):: l    !< List.
  integer(I4P)::                             leng !< Length of list.
  type(Type_Block), pointer::                cur  !< Pointer for scanning leafs list.
  !---------------------------------------------------------------------------------------------------------------------------------

  !---------------------------------------------------------------------------------------------------------------------------------
  cur => l ; leng = 0_I4P
  do while(associated(cur))
    leng = leng + 1_I4P ; cur => cur%bnl
  enddo
  return
  !---------------------------------------------------------------------------------------------------------------------------------
  endfunction len_list

  !> @brief Subroutine for blocks heavier than Wi.
  subroutine split_block_gt_Wi(mgl,Wi,leaf)
  !---------------------------------------------------------------------------------------------------------------------------------
  implicit none
  integer(I4P),     intent(IN)::             mgl      !< Number of levels of multi-grid to be preserved.
  integer(I8P),     intent(IN)::             Wi       !< Ideal work load per processor.
  type(Type_Block), intent(INOUT), pointer:: leaf     !< Leafs list.
  integer(I4P)::                             it       !< Counters.
  type(Type_Block), pointer::                cur,next !< Pointers for scanning leafs list.
  !---------------------------------------------------------------------------------------------------------------------------------

  !---------------------------------------------------------------------------------------------------------------------------------
  it = 0_I4P
  do while(leaf%Wb>Wi)
    cur => leaf
    do while(associated(cur))
      it = it + 1_I4P
      next => cur%bnl
      if (cur%Wb > Wi) then
        call cur%split(mgl=mgl,leaf=leaf)
      endif
      cur => next
    enddo
  enddo
  return
  !---------------------------------------------------------------------------------------------------------------------------------
  endsubroutine split_block_gt_Wi

  !> @brief Subroutine for splitting leafs.
  subroutine split_block_leaf(mgl,Wi,Thresh,leaf)
  !---------------------------------------------------------------------------------------------------------------------------------
  implicit none
  integer(I4P),              intent(IN)::    mgl                 !< Number of levels of multi-grid to be preserved.
  integer(I8P),              intent(IN)::    Wi                  !< Ideal work load per processor.
  real(R8P),                 intent(IN)::    Thresh              !< Threshold of blocks splitting.
  type(Type_Block), pointer, intent(INOUT):: leaf                !< Leafs list.
  logical::                                  split_performed     !< Split performed or not (when split_mode=prime).
  type(Type_Block), pointer::                bsplit              !< Pointer to block to split.
  type(Type_Block), pointer::                cur,last            !< Pointers for scanning leafs list.
  integer(I8P)::                             Wbmin,Wbmax,Wbsplit !< Work loads for driving the spitting.
  !---------------------------------------------------------------------------------------------------------------------------------

  !---------------------------------------------------------------------------------------------------------------------------------
  write(stdout,'(A)')' Starting leaf Wb,Wi:'//trim(str(.true.,leaf%Wb))//' '//trim(str(.true.,Wi))
  Wbmax = leaf%Wb
  cur => leaf
  do while(associated(cur%bnl))
    cur => cur%bnl
  enddo
  last => cur
  Wbmin = last%Wb
  Wbsplit = nint(Wbmin + Thresh*(Wbmax-Wbmin),I8P)
  split_performed = .false.
  cur => leaf
  do_bs: do while(associated(cur))
    if (cur%Wb<=Wbsplit) then
      bsplit => cur
      do while(associated(bsplit))
        call bsplit%split(split_performed=split_performed,mgl=mgl,leaf=leaf)
        if (split_performed) return
        bsplit => bsplit%bpl
      enddo
      exit do_bs !return
    else
      cur => cur%bnl
    endif
  enddo do_bs
  if (.not.split_performed) then
    write(stderr,'(A)')' Error: split failed!'
!    write(stderr,'(A)')' Block is =>'// &
!                       ' Ancestor: '//trim(str(.true.,bsplit%a))//&
!                       ' Level: '//trim(str(.true.,bsplit%l))//&
!                       ' Sizes: Ni-'//trim(str(.true.,bsplit%Ni))//&
!                              ' Nj-'//trim(str(.true.,bsplit%Nj))//&
!                              ' Nk-'//trim(str(.true.,bsplit%Nk))
    stop
  endif
  return
  !---------------------------------------------------------------------------------------------------------------------------------
  endsubroutine split_block_leaf

  !> @brief Subroutine for assigning blocks to processors.
  subroutine assign_block_leaf(leaf,Wi,bal,proc)
  !---------------------------------------------------------------------------------------------------------------------------------
  implicit none
  type(Type_Block), intent(IN), target:: leaf     !< Leafs list.
  integer(I8P),     intent(IN)::         Wi       !< Ideal work load per processor.
  real(R8P),        intent(IN)::         bal      !< Tollerance of maximum balancing.
  type(Type_Proc),  intent(INOUT)::      proc(1:) !< Processors data.
  type(Type_Block), pointer::            cur      !< Pointer for scanning leafs list.
  integer(I4P)::                         l        !< Counter.
  !---------------------------------------------------------------------------------------------------------------------------------

  !---------------------------------------------------------------------------------------------------------------------------------
  cur => leaf
  do while(associated(cur))
    l = minloc(proc(:)%Wp,dim=1)
    cur%p = l
    proc(l)%Wp = proc(l)%Wp + cur%Wb
    proc(l)%Wpr = proc(l)%Wp*100._R8P/Wi
    proc(l)%balanced=.false.
    if ((proc(l)%Wpr>(100._R8P-bal)).AND.(proc(l)%Wpr<(100._R8P+bal))) proc(l)%balanced=.true.
    proc(l)%Nb = proc(l)%Nb + 1
    cur => cur%bnl
  enddo
  return
  !---------------------------------------------------------------------------------------------------------------------------------
  endsubroutine assign_block_leaf

  !> @brief Subroutine for initializing sorted (descending) list of leafs.
  subroutine init_leaf(check,block,leaf)
  !---------------------------------------------------------------------------------------------------------------------------------
  implicit none
  logical, optional,         intent(IN)::    check         !< Check initial leafs list.
  type(Type_Block), target,  intent(IN)::    block(1:)     !< Blocks data.
  type(Type_Block), pointer, intent(INOUT):: leaf          !< Leafs list.
  type(Type_Block), pointer::                cur,prev,last !< Pointers for scanning leafs list.
  integer, allocatable::                     Wb_array(:)   !< For ordering.
  integer::                                  b_Wbmax       !< Temporary index.
  integer::                                  Nb            !< Number of ancestor blocks.
  integer::                                  i,b           !< Counters.
  !---------------------------------------------------------------------------------------------------------------------------------

  !---------------------------------------------------------------------------------------------------------------------------------
  Nb=size(block)
  allocate(Wb_array(1:Nb))
  do b=1,Nb
    Wb_array(b) = block(b)%Wb
  enddo
  b_Wbmax=maxloc(Wb_array,dim=1) ; Wb_array(b_Wbmax) = -1
  leaf  => block(b_Wbmax)
  cur   => leaf
  prev  => leaf
  do b=2,Nb
    b_Wbmax=maxloc(Wb_array,dim=1) ; Wb_array(b_Wbmax) = -1
    cur%bnl  => block(b_Wbmax)
    cur      => cur%bnl
    cur%bpl  => prev
    prev     => cur
  enddo
  last => cur
  deallocate(Wb_array)
  if (present(check)) then
    if (check) then
      i=0
      cur => leaf
      do while(associated(cur)) ;
         i=i+1
         write(stdout,'(A)')'Initial leafs list (descending): i,Wb:'//trim(str(.true.,i))//' '//trim(str(.true.,cur%Wb))
         cur => cur%bnl
      enddo
      cur => last
      i=Nb
      do while(associated(cur))
         write(stdout,'(A)')'Initial leafs list (ascending): i,Wb:'//trim(str(.true.,i))//' '//trim(str(.true.,cur%Wb))
         cur => cur%bpl
         i=i-1
      enddo
    endif
  endif
  return
  !---------------------------------------------------------------------------------------------------------------------------------
  endsubroutine init_leaf

  !> @brief Subroutine for checking balancing procedure: (a) Nb growth and (b) leafs list.
  subroutine converging_check(block,leaf,save_blk_growth,Nbs)
  !---------------------------------------------------------------------------------------------------------------------------------
  implicit none
  type(Type_Block), target,  intent(IN)::    block(1:)       !< Blocks data.
  type(Type_Block), pointer, intent(IN)::    leaf            !< Leafs list.
  logical,                   intent(IN)::    save_blk_growth !< Flag for saving blocks growth history.
  integer(I4P),              intent(INOUT):: Nbs             !< Number of blocks of current iteration.
  type(Type_Block), pointer::                cur             !< Pointer for scanning the list.
  integer(I4P)::                             Nb              !< Number of ancestors blocks.
  integer(I4P)::                             Nbs_old         !< Number of blocks of previous iteration.
  integer(I4P), allocatable::                Nbs_block(:)    !< Array of Number of blocks for each ancestor.
  integer(I4P)::                             b,i             !< Counters.
  integer(I4P)::                             u               !< File unit for growth behaviour.
  !---------------------------------------------------------------------------------------------------------------------------------

  !---------------------------------------------------------------------------------------------------------------------------------
  Nb=size(block,dim=1)
  allocate(Nbs_block(1:Nb))
  Nbs_old=Nbs ; Nbs = 0 ; Nbs_block = 0
  do b=1,Nb
    call block(b)%get_Nbs(Nbs=Nbs)
    call block(b)%get_Nbs(Nbs=Nbs_block(b))
  enddo
  if (save_blk_growth) then
    open(unit=Get_Unit(u),file='blocks_growth.dat',position='append')
    write(u,'('//trim(str(.true.,Nb))//'A)')(' '//str(n=Nbs_block(b)),b=1,Nb)
    close(u)
  endif
  if (Nbs == Nbs_old) then
    write(stderr,'(A)')'Number of split blocks: '//trim(str(.true.,Nbs))
    write(stderr,'(A)')'Largest block is =>'// &
                       ' Ancestor: '//trim(str(.true.,leaf%a))//&
                       ' Level: '//trim(str(.true.,leaf%l))//&
                       ' Sizes: Ni-'//trim(str(.true.,leaf%Ni))//&
                              ' Nj-'//trim(str(.true.,leaf%Nj))//&
                              ' Nk-'//trim(str(.true.,leaf%Nk))
    write(stderr,'(A)')'Cannot split more! Sorry, I am exiting...'
    stop
  endif
  cur => leaf
  i=0
  do while(associated(cur))
    i=i+1
    cur => cur%bnl
  enddo
  if (i/=Nbs) then
    write(stderr,'(A)')'Number of sorted leafs :'//trim(str(.true.,i))//' not equal to split blocks Nbs: '//trim(str(.true.,Nbs))
    write(stderr,'(A)')'Error! I am exiting...'
    stop
  endif
  deallocate(Nbs_block)
  return
  !---------------------------------------------------------------------------------------------------------------------------------
  endsubroutine converging_check

  !> @brief Subroutine for recursively saving output files (blocks list files, bsplit.par of each level and proc.input).
  recursive subroutine save_output(block,froot,mgl,save_blk_his,save_lvl_lis,leaf)
  !---------------------------------------------------------------------------------------------------------------------------------
  implicit none
  type(Type_Block), target,  intent(INOUT):: block(1:)    !< Blocks data.
  character(*),              intent(IN)::    froot        !< Root file name.
  integer(I4P),              intent(IN)::    mgl          !< Number of levels of multi-grid.
  logical,                   intent(IN)::    save_blk_his !< Flag for saving the splitting history of each original block.
  logical,                   intent(IN)::    save_lvl_lis !< Flag for saving levele list.
  type(Type_Block), pointer, intent(INOUT):: leaf         !< Leafs list.
  !---------------------------------------------------------------------------------------------------------------------------------

  !---------------------------------------------------------------------------------------------------------------------------------
  if (save_blk_his) call save_block_split_his(block=block)
  if (save_lvl_lis) call save_level_lis(block=block)
                    call save_bsplit_par(block=block,froot=froot,mgl=mgl,leaf=leaf)
                    call save_proc_input(block=block,leaf=leaf)
  return
  !---------------------------------------------------------------------------------------------------------------------------------
  contains
    subroutine create_fake_children(leaf,lmax)
    !-------------------------------------------------------------------------------------------------------------------------------
    implicit none
    type(Type_Block), pointer, intent(INOUT):: leaf    !< List of leafs.
    integer(I4P),              intent(IN)::    lmax    !< Maximum level.
    type(Type_Block), pointer::                cur,tmp !< Pointers for list scanning.
    integer(I4P)::                             l       !< Counter.
    !-------------------------------------------------------------------------------------------------------------------------------

    !-------------------------------------------------------------------------------------------------------------------------------
    cur => leaf
    do while(associated(cur))
      if (cur%l<lmax) then
        ! creating fake children
        tmp => cur
        do l=1,lmax-cur%l
          tmp%spt=.true. ; tmp%dir=0 ; tmp%Ns=1
          allocate(tmp%bs(1))
          call tmp%bs(1)%set(a=tmp%a,l=tmp%l+1,ba=tmp%ba,b=[tmp%b,1],p=tmp%p,Ni=tmp%Ni,Nj=tmp%Nj,Nk=tmp%Nk)
          tmp => tmp%bs(1)
        enddo
        tmp%spt=.false.
      endif
      cur => cur%bnl
    enddo
    return
    !-------------------------------------------------------------------------------------------------------------------------------
    endsubroutine create_fake_children

    !> @brief Subroutine for saving the split history of each ancestor block.
    subroutine save_block_split_his(block)
    !-------------------------------------------------------------------------------------------------------------------------------
    implicit none
    type(Type_Block), target,  intent(INOUT):: block(1:) !< Blocks data.
    integer(I4P)::                             b         !< Counter.
    !-------------------------------------------------------------------------------------------------------------------------------

    !-------------------------------------------------------------------------------------------------------------------------------
    do b=1,size(block,dim=1)
      call block(b)%save
    enddo
    return
    !-------------------------------------------------------------------------------------------------------------------------------
    endsubroutine save_block_split_his

    !> @brief Subroutine for saving the list of blocks of each level.
    subroutine save_level_lis(block)
    !-------------------------------------------------------------------------------------------------------------------------------
    implicit none
    type(Type_Block), target,  intent(INOUT):: block(1:) !< Blocks data.
    integer(I4P), allocatable::                u(:)      !< Logical units for levels list [0:lmax].
    integer(I4P)::                             Nb        !< Number of original (ancestor) blocks.
    integer(I4P)::                             lmax      !< Maximum level of splits.
    type(Type_SL_List), allocatable::          llist(:)  !< Levels list [0:lmax].
    character(Nc),      allocatable::          blist(:)  !< Blocks list.
    integer(I4P)::                             b,l       !< Counters.
    !-------------------------------------------------------------------------------------------------------------------------------

    !-------------------------------------------------------------------------------------------------------------------------------
    Nb = size(block,dim=1)
    lmax = 0
    do b=1,Nb
      call block(b)%get_lmax(lmax=lmax)
    enddo
    allocate(u(0:lmax))
    do l=0,lmax
      open(unit=Get_Unit(u(l)),file='level'//trim(strz(4,l))//'.lis')
    enddo
    allocate(llist(0:lmax))
    do l=0,lmax
      do b=1,Nb
        call get_blocks_of_level(block=block(b),l=l,list=llist(l))
      enddo
    enddo
    ! converting list to character array and saving to output files
    do l=0,lmax
      call llist(l)%array(Nc,blist)
      do b=1,size(blist,dim=1)
        write(u(l),'(A)')trim(str(.true.,b))//' '//trim(blist(b))
      enddo
    enddo
    do l=0,lmax
      close(u(l))
      call llist(l)%free
    enddo
    deallocate(u,llist,blist)
    return
    !-------------------------------------------------------------------------------------------------------------------------------
    endsubroutine save_level_lis

    !> @brief Subroutine for saving bsplit####.par files.
    subroutine save_bsplit_par(block,froot,mgl,leaf)
    !-------------------------------------------------------------------------------------------------------------------------------
    implicit none
    type(Type_Block), target,  intent(INOUT):: block(1:) !< Blocks data.
    character(*),              intent(IN)::    froot     !< Root file name.
    integer(I4P),              intent(IN)::    mgl       !< Number of levels of multi-grid.
    type(Type_Block), pointer, intent(INOUT):: leaf      !< Leafs list.
    integer(I4P)::                             Nb        !< Number of original (ancestor) blocks.
    integer(I4P)::                             lmax      !< Maximum level of splits.
    type(Type_SL_List), allocatable::          llist(:)  !< Levels list [0:lmax].
    character(Nc),      allocatable::          blist(:)  !< Blocks list.
    integer(I4P), allocatable::                u(:)      !< Logical units for bsplit####.par files [1:lmax].
    integer(I4P)::                             b,l,lc    !< Counters.
    !-------------------------------------------------------------------------------------------------------------------------------

    !-------------------------------------------------------------------------------------------------------------------------------
    ! computing the maximum level
    lmax = 0
    do b=1,size(block,dim=1)
      call block(b)%get_lmax(lmax=lmax)
    enddo
    if (lmax==0) then
      write(stdout,'(A)')' No split is necessary thus no bsplit.par is saved!'
      return
    endif
    ! creating fake children blocks if necessary
    call create_fake_children(leaf=leaf,lmax=lmax)
    ! creating levels lists
    allocate(llist(0:lmax))
    do l=0,lmax
      do b=1,size(block,dim=1)
        call get_blocks_of_level(block=block(b),l=l,list=llist(l))
      enddo
    enddo
    ! creating bsplit####.par files
    allocate(u(1:lmax))
    do l=1,lmax
      open(unit=Get_Unit(u(l)),file='bsplit'//trim(strz(4,l))//'.par')
      write(u(l),'(A)')"'xxx'   radice file soluzione"
      write(u(l),'(A)')"'"//trim(froot)//repeat('SPLIT',l-1)//"' radice file reticolo"
      write(u(l),'(A)')"'"//trim(froot)//repeat('SPLIT',l-1)//"' radice file cc"
      write(u(l),'(A)')trim(str(.true.,mgl))//" n livelli MG"
      write(u(l),'(A)')"0  variabili al tempo n"
      write(u(l),'(A)')"0  variabili al tempo n-1"
      write(u(l),'(A)')"1  stampe di debug"
    enddo
    ! saving bsplit####.par data
    do l=0,lmax-1
      call llist(l)%array(Nc,blist)
      do b=1,size(blist,dim=1)
        call parse_block_string(string=trim(str(.true.,b))//' '//trim(blist(b)),u=u(l+1))
      enddo
    enddo
    ! freeing memory
    call llist(0)%free
    do l=1,lmax
      close(u(l))
      call llist(l)%free
    enddo
    deallocate(u,llist,blist)
    return
    !-------------------------------------------------------------------------------------------------------------------------------
    endsubroutine save_bsplit_par

    !> @brief Subroutine for saving proc.input file.
    subroutine save_proc_input(block,leaf)
    !-------------------------------------------------------------------------------------------------------------------------------
    implicit none
    type(Type_Block), target,  intent(INOUT):: block(1:) !< Blocks data.
    type(Type_Block), pointer, intent(INOUT):: leaf      !< Leafs list.
    type(Type_Block), pointer::                cur       !< Pointer for scanning leafs list.
    integer(I4P)::                             Nb        !< Number of blocks.
    integer(I4P)::                             u         !< Logical unit for proc.input file.
    character(20)::                            date      !< Actual date.
    integer(I4P)::                             lmax      !< Maximum level of splits.
    integer(I4P)::                             b,p       !< Counters.
    type(Type_SL_List)::                       llist     !< Maximum level list of blocks.
    character(Nc), allocatable::               blist(:)  !< Blocks list.
    !-------------------------------------------------------------------------------------------------------------------------------

    !-------------------------------------------------------------------------------------------------------------------------------
    date = Get_Date_String()
    Nb = len_list(l=leaf)
    lmax = 0
    do b=1,size(block,dim=1)
      call block(b)%get_lmax(lmax=lmax)
    enddo
    do b=1,size(block,dim=1)
      call get_blocks_of_level(block=block(b),l=lmax,list=llist)
    enddo
    call llist%array(Nc,blist)
    open(unit=Get_Unit(u),file='proc.input')
    write(u,'(A)')repeat('-',43)//'generated by loadbalance '//trim(date)//repeat('-',44)
    write(u,'(A)')
    write(u,'(A)')
    write(u,'(A)') trim(str(.true.,Nb))//' Numero totale blocchi (compresi b.i. e d.a.)'
    write(u,'(A)')
    write(u,'(A)') '    blocco    gruppo     corpo      proc'
    write(u,'(A)')repeat('-',132)
    do b=1,size(blist,dim=1)
      p = cton(trim(blist(b)(1:index(blist(b),' '))),I4P) - 1
      write(u,'(A)')trim(str('(I10)',b))//'         0         0 '//trim(str('(I9)',p))//' ! '//&
                    trim(str(n=cton(trim(blist(b)(index(trim(blist(b)),' ',back=.true.):)),I4P)))
    enddo
    close(u)
    deallocate(blist)
    return
    !-------------------------------------------------------------------------------------------------------------------------------
    endsubroutine save_proc_input

    !> @brief Subroutine for storing blocks list of each level.
    recursive subroutine get_blocks_of_level(block,l,list)
    !-------------------------------------------------------------------------------------------------------------------------------
    implicit none
    type(Type_Block),   intent(IN)::    block   !< Block data.
    integer(I4P),       intent(IN)::    l       !< Current level.
    type(Type_SL_List), intent(INOUT):: list    !< Level list.
    character(Nc)::                     sbuffer !< String buffer.
    integer(I4P)::                      s       !< Counter.
    !-------------------------------------------------------------------------------------------------------------------------------

    !-------------------------------------------------------------------------------------------------------------------------------
    if (block%l==l) then
      sbuffer = trim(str(.true.,block%p))//' '//trim(str(.true.,block%a))//' '//trim(str(.true.,block%Ns))
      sbuffer = trim(sbuffer)//' '//trim(str(.true.,block%dir))//' '//trim(str(.true.,block%Nijk))
      sbuffer = trim(sbuffer)//' '//trim(str(.true.,block%Ni*block%Nj*block%Nk))
      call list%putt(sbuffer)
    elseif (block%l<l.AND.block%spt) then
      do s=1,block%Ns
        call get_blocks_of_level(block=block%bs(s),l=l,list=list)
      enddo
    else
      sbuffer = trim(str(.true.,block%p))//' '//trim(str(.true.,block%a))//' '//trim(str(.true.,block%Ns))
      call list%putt(sbuffer)
    endif
    return
    !-------------------------------------------------------------------------------------------------------------------------------
    endsubroutine get_blocks_of_level

    !> @brief Subroutine for parsing string data of blocks.
    subroutine parse_block_string(string,u)
    !-------------------------------------------------------------------------------------------------------------------------------
    implicit none
    character(*), intent(IN)::            string  !< Block string data.
    integer(I4P), intent(IN)::            u       !< Logical unit.
    character(len(string)), allocatable:: toks(:) !< String tokens.
    integer(I4P)::                        Ns      !< Number of splits.
    integer(I4P)::                        Nijk    !< Position of splits.
    integer(I4P)::                        s       !< Counter.
    !-------------------------------------------------------------------------------------------------------------------------------

    !-------------------------------------------------------------------------------------------------------------------------------
    call tokenize(strin=string,delimiter=' ',toks=toks)
    Ns = cton(toks(4),I4P)
    if (Ns>1) then
      Nijk = cton(toks(6),I4P)
      do s=1,Ns-1
        write(u,'(A)')trim(toks(1))//' '//trim(toks(5))//' '//trim(str(.true.,s*Nijk))
      enddo
    endif
    deallocate (toks)
    return
    !-------------------------------------------------------------------------------------------------------------------------------
    endsubroutine parse_block_string
  endsubroutine save_output
endmodule Lib_Balancing

!> @brief Program for performing load balancing.
program loadbalance
!-----------------------------------------------------------------------------------------------------------------------------------
USE IR_Precision
USE Data_Type_OS
USE Data_Type_SL_List
USE Lib_Balancing
USE Lib_IO_Misc
!-----------------------------------------------------------------------------------------------------------------------------------

!-----------------------------------------------------------------------------------------------------------------------------------
implicit none
type(Type_OS):: OS !< Running architecture.
! main data structures
integer(I4P)::                  Nb=0     !< Number of blocks.
type(Type_Block), pointer::     block(:) !< Blocks data [1:Nb].
integer(I4P)::                  Np=8     !< Number of processors.
type(Type_Proc),  allocatable:: proc(:)  !< Processors data [1:Np].
! files handling variables
character(Nc):: fnamein=''                !< Input file name.
character(Nc):: froot=''                  !< Root file name.
integer(I4P)::  uin=0                     !< Input file logic unit.
character(13):: endianism='LITTLE_ENDIAN' !< Bit ordering of binary files.
logical::       save_blk_his=.false.      !< Flag for saving the splitting history of each original block.
logical::       save_lvl_lis=.false.      !< Flag for saving levele list.
logical::       save_blk_growth=.false.   !< Flag for saving blocks growth history.
logical::       is_file=.false.           !< Flag for inquiring the existance of input file.
! balancing parameters
integer(I4P)::                Nbs=0              !< Number of blocks after splitting.
real(R8P)::                   bal=3._R8P         !< Tollerance of maximum balancing.
integer(I8P)::                Wi=0               !< Ideal work load per processor.
integer(I8P)::                Wmax=0             !< Maximum work load over blocks.
integer(I4P)::                bmax=0             !< Index of heaviest block.
integer(I4P),   allocatable:: pf(:)              !< Prime factors for block splitting [...,9,7,5,3,2].
character(Nc), allocatable::  pfc(:)             !< Dummy strings for prime factors parsing.
integer(I4P)::                mgl=4              !< Number of levels of multi-grid.
integer(I4P)::                imax=1000          !< Maximum number of balancing iterations.
real(R8P)::                   Wprmax=0._R8P      !< Maximum Wpr.
real(R8P)::                   thresh             !< Threshold of splitting.
real(R8P)::                   threshMin=1._R8P   !< Minimum split threshold.
real(R8P)::                   threshMax=1._R8P   !< Maximum split threshold.
integer(I4P)::                threshNum=1_I4P    !< Number of split threshold.
real(R8P)::                   threshDelta=0._R8P !< Delta split threshold.
! command line parsing variables
integer(I4P)::   Nca=0      !< Command line argument number.
character(100):: switch,dum !< Command line argument switches.
! auxiliary variables
integer(I4P):: i,j,k,b,l,c,p,t !< Counters.
!-----------------------------------------------------------------------------------------------------------------------------------

!-----------------------------------------------------------------------------------------------------------------------------------
! parsing command line arguments
Nca = command_argument_count()
if (Nca==0) then
  call print_usage
  stop
endif
c = 0
do while (c<Nca)
  c = c + 1
  call get_command_argument(c,switch)
  select case(trim(switch))
  case('-i')
    call get_command_argument(c+1,fnamein) ; c = c + 1
  case('-check')
    call get_command_argument(c+1,dum) ; c = c + 1
    fnamein = check(fnamei=trim(dum))
  case('-np')
    call get_command_argument(c+1,dum) ; c = c + 1
    Np = cton(dum,I4P)
  case('-be')
    endianism = 'BIG_ENDIAN'
  case('-le')
    endianism = 'LITTLE_ENDIAN'
  case('-pf')
    call get_command_argument(c+1,dum) ; c = c + 1
    call tokenize(strin=dum,delimiter='-',toks=pfc)
    allocate(pf(1:size(pfc,dim=1)))
    do p=1,size(pfc,dim=1)
      pf(p) = cton(pfc(p),I4P)
    enddo
    if (allocated(pfc)) deallocate(pfc)
  case('-b')
    call get_command_argument(c+1,dum) ; c = c + 1
    bal = cton(dum,1._R8P)
  case('-imax')
    call get_command_argument(c+1,dum) ; c = c + 1
    imax = cton(dum,I4P)
  case('-mgl')
    call get_command_argument(c+1,dum) ; c = c + 1
    mgl = cton(dum,I4P) ! mgl = mgl - 1
  case('-save_blk_his')
    save_blk_his = .true.
  case('-save_lvl_lis')
    save_lvl_lis = .true.
  case('-save_blk_grw')
    save_blk_growth = .true.
  case('-thresh')
    call get_command_argument(c+1,dum) ; c = c + 1
    call tokenize(strin=dum,delimiter='-',toks=pfc)
    if(size(pfc,dim=1) /= 3) then
      write(stderr,'(A)')' -thresh requires 3 arguments, min/max fraction and number of thresholds, e.g. 0.2-0.8-5'
      call print_usage
      stop
    endif
    threshMin = cton(pfc(1),1._R8P)
    threshMax = cton(pfc(2),1._R8P)
    threshNum = cton(pfc(3),1_I4P)
    if(threshNum>1) threshDelta = (threshMax-threshMin)/(threshNum-1)
    if(threshMin < 0._R8P .or. threshMax > 1._R8P .or. threshMin > threshMax  &
          .or. (abs(threshMax-(threshMin+(threshNum-1)*threshDelta)) > 0.00001_R8P)) then
      write(stderr,'(A)')' -thresh requires 3 arguments, min/max fraction and number of thresholds, e.g. 0.2-0.8-5'
      call print_usage
      stop
    endif
    write(500,*)'DEBUG: Manual Threshold activated: ',threshMin,threshMax,threshNum,threshDelta
  case default
    write(stderr,'(A)')' Switch "'//trim(switch)//'" unknown!'
    call print_usage
    stop
  endselect
enddo
if (trim(fnamein)=='') then
  write(stderr,'(A)')' Error: a valid file name for input file must be provided!'
  stop
else
  froot = OS%basename(trim(fnamein))                                      ! basename of fnamein
  if (index(froot,'.grd')>0) froot = trim(froot(1:index(froot,'.grd')-1)) ! trimming .grd
  do l=1,99 ! loop over admissible levels
    if (index(froot,'.'//strz(2,l))>0) then
      froot = trim(froot(1:index(froot,'.'//strz(2,l))-1))                ! trimming .#grl
    endif
  enddo
  inquire(file=trim(fnamein),exist=is_file)
  if (.not.is_file) then
    write(stderr,'(A)')' Error: the input file "'//trim(fnamein)//'" does not exist!'
    stop
  endif
endif
if (.not.allocated(pf)) then
  allocate(pf(1:2)) ; pf = [3,2]
endif
! printing parameters of the balancing
call print_defaults
! allocating processors data
allocate(proc(1:Np))
! loading input data
#ifdef cXLF
open(unit = Get_Unit(uin), file = trim(fnamein), form = 'UNFORMATTED')
#else
open(unit = Get_Unit(uin), file = trim(fnamein), form = 'UNFORMATTED', convert = trim(endianism))
#endif
read(uin)Nb
! allocating blocks data
allocate(block(1:Nb))
! loading data of original blocks
do b=1,Nb
  read(uin)i,j,k ; call block(b)%set(a=b,l=0,ba=b,b=(/b/),Ni=i,Nj=j,Nk=k)
enddo
close(uin)
! computing global variables
Wi=int(sum(block%Wb)/Np)
Wmax=maxval(block%Wb)
bmax=maxloc(block%Wb,dim=1)
! initial multigrid check
do b=1,Nb
  if(.not.(block(b)%mgl_check(mgl=mgl))) then
    write(stderr,'(A)')'The block a:'//trim(str(.true.,block(b)%a))//&
                                ' l:'//trim(str(.true.,block(b)%l))//&
                                ' ba:'//trim(str(.true.,block(b)%ba))//&
                                ' i => Ni: '//trim(str(.true.,block(b)%Ni))//&
                                ' j => Nj: '//trim(str(.true.,block(b)%Nj))//&
                                ' k => Nk: '//trim(str(.true.,block(b)%Nk))//&
                                ' does not have enough levels of MG!'
    write(stderr,'(A)')'MG constraint violation! Sorry, I am exiting...'
    stop
  endif
enddo
! intialize leafs list
call init_leaf(check=.true.,block=block,leaf=leaf)
! splitting blocks heavier than Wi
call split_block_gt_Wi(mgl=mgl,Wi=Wi,leaf=leaf)
Nbs=0
do b=1,Nb
  call block(b)%print
  call block(b)%get_Nbs(Nbs=Nbs)
enddo
! balancing
i = 0
balance: do
  i = i + 1
  ! initializing processors
  do p=1,Np
    call proc(p)%init
  enddo
  ! assigning blocks
  call assign_block_leaf(leaf=leaf,Wi=Wi,bal=bal,proc=proc)
  ! checking if all blocks have been assigned to a processor
  if (Nbs/=sum(proc%Nb)) then
    write(stderr,'(A)')"Error: some blocks have not been assigned to a processor Nb:"//trim(str(.true.,Nbs))//"/="//&
                       trim(str(.true.,sum(proc%Nb)))
    stop
  endif
  Wprmax = maxval(abs(proc(:)%Wpr-100._R8P))
  write(stdout,'(A)')'Balancing Step i: '//trim(str(.false.,i))//' ; Maximum un-balance '//trim(str('(F5.2)',Wprmax))&
                     //'% ; Number of blocks:'//trim(str(.false.,Nbs))
  ! checking balancing
  if (all(proc(:)%balanced,dim=1).OR.(i>=imax)) exit balance
  ! some processors are not balanced their blocks (some of) must be split
  do t=1,threshNum
    thresh = threshMin + (t-1)*threshDelta
    call split_block_leaf(mgl=mgl,Wi=Wi,Thresh=thresh,leaf=leaf)
!    call split_block_leaf(mgl=mgl,Wi=Wi,Thresh=real(t/(tmax*1._R8P),R8P),leaf=leaf)
  enddo
  ! check if the procedure is converging
  call converging_check(block=block,leaf=leaf,save_blk_growth=save_blk_growth,Nbs=Nbs)
enddo balance
! initializing processors
do p=1,Np
  call proc(p)%init
enddo
! assigning blocks for the last configuration
call assign_block_leaf(leaf=leaf,Wi=Wi,bal=bal,proc=proc)
! printing stats
call print_stats
! writing output files
call save_output(block=block,froot=trim(froot),mgl=mgl,save_blk_his=save_blk_his,save_lvl_lis=save_lvl_lis,leaf=leaf)
stop
!-----------------------------------------------------------------------------------------------------------------------------------
contains
  !> @brief Subroutine for printing usage help message.
  subroutine print_usage()
  !---------------------------------------------------------------------------------------------------------------------------------
  implicit none
  !---------------------------------------------------------------------------------------------------------------------------------

  !---------------------------------------------------------------------------------------------------------------------------------
  write(stdout,'(A)')' Load balancing for Xnavis'
  write(stdout,'(A)')'   Usage:'
  write(stdout,'(A)')'     loadbalance [-swt [arg]]'
  write(stdout,'(A)')'       -i input_file_name'
  write(stdout,'(A)')'       -check check_param_file_name => for checking the algoritm with simple blocks structure'
  write(stdout,'(A)')'       -np #procs (default 8)'
  write(stdout,'(A)')'       -be => big endian bits ordering'
  write(stdout,'(A)')'       -le => little endian bits ordering (default)'
  write(stdout,'(A)')'       -b balancing_tolerance (default 3.0%)'
  write(stdout,'(A)')'       -imax maximum_balancing_iteration (default 1000)'
  write(stdout,'(A)')'       -mgl number_of_multi-grid_levels (default 4)'
  write(stdout,'(A)')'       -thresh => manual tuning of splitting, min/max/number (default 1.-1.-1)'
  write(stdout,'(A)')'       -save_blk_his => save splitting history of each original block (default no)'
  write(stdout,'(A)')'       -save_lvl_lis => save level block list for each level (default no)'
  write(stdout,'(A)')'       -save_blk_grw => save blocks growth history (default no)'
  write(stdout,'(A)')'   Examples:'
  write(stdout,'(A)')'     loadbalance -check check.dat                  ! checking the algoritm with simple block structure'
  write(stdout,'(A)')'     loadbalance -i cc.01                          ! little endian input file and 8 procs'
  write(stdout,'(A)')'     loadbalance -i cc.01 -np 16 -be               ! big endian input file and 16 procs'
  write(stdout,'(A)')'     loadbalance -i cc.01 -np 32 -b 2.             ! maximum admissible unbalance factor of 2%'
  write(stdout,'(A)')'     loadbalance -i cc.01 -np 16 -imax 100         ! maximum number of balancing iterations set to 100'
  write(stdout,'(A)')'     loadbalance -i cc.01 -np 32 -save_blk_his     ! save block splitting history for each original block'
  write(stdout,'(A)')'     loadbalance -i cc.01 -np 32 -thresh 0.2-0.8-3 ! each iteration three blocks are splitted:'//&
                                                                        ' 20%, 40% and 60% normalized size '
  return
  !---------------------------------------------------------------------------------------------------------------------------------
  endsubroutine print_usage

  !> @brief Subroutine for printing values of defaults.
  subroutine print_defaults()
  !---------------------------------------------------------------------------------------------------------------------------------
  implicit none
  !---------------------------------------------------------------------------------------------------------------------------------

  !---------------------------------------------------------------------------------------------------------------------------------
  write(stdout,'(A)')' Input file :'//trim(fnamein)
  write(stdout,'(A)')' Number of processors :'//trim(str(.true.,Np))
  write(stdout,'(A)')' Bit ordering :'//trim(endianism)
  write(stdout,'(A)')' Balancing tolerance :'//trim(str('(F10.3)',bal))//'%'
  write(stdout,'(A)')' Maximum number of iterations :'//trim(str(.true.,imax))
  write(stdout,'(A)')' Number of multigrid levels :'//trim(str(.true.,mgl))
  return
  !---------------------------------------------------------------------------------------------------------------------------------
  endsubroutine print_defaults

  !> @brief Subroutine for printing balancing statitisc.
  subroutine print_stats()
  !---------------------------------------------------------------------------------------------------------------------------------
  implicit none
  character(1000):: sbuffer !< String buffer.
  integer(I4P)::    b,p     !< Counters.
  !---------------------------------------------------------------------------------------------------------------------------------

  !---------------------------------------------------------------------------------------------------------------------------------
  write(stdout,'(A)')' Number of original blocks '//trim(str(.true.,Nb))
  Nbs=0
  do b=1,Nb
    call block(b)%print
    call block(b)%get_Nbs(Nbs=Nbs)
  enddo
  Wprmax = MinR8P
  do p=1,Np
    sbuffer='   Processor:'//trim(str('(I7)',p))//', Work Load:'//trim(str('(I8)',proc(p)%Wp))//&
            ', Balance:'//trim(str('(F8.2)',proc(p)%Wpr-100._R8P))//'%'
    write(stdout,'(A)')trim(sbuffer)
    Wprmax = max(Wprmax,abs(proc(p)%Wpr-100._R8P))
  enddo
  write(stdout,'(A)')' Total Work Load '//trim(str(.true.,sum(block%Wb)))
  write(stdout,'(A)')' Ideal Work Load per processor '//trim(str(.true.,Wi))
  write(stdout,'(A)')' Maximum Work Load over ancestor blocks '//trim(str(.true.,Wmax))//' found in block '//trim(str(.true.,bmax))
  write(stdout,'(A)')' Number of split blocks '//trim(str(.true.,Nbs))
  write(stdout,'(A)')' Number of balancing iterations '//trim(str(.true.,i))
  write(stdout,'(A)')' Number of processors '//trim(str(.true.,Np))
  write(stdout,'(A)')' Maximum un-balance '//trim(str('(F8.2)',Wprmax))//'%'
  return
  !---------------------------------------------------------------------------------------------------------------------------------
  endsubroutine print_stats

  !> @brief Function for checking the algorithm with simple blocks structure described into ASCII file parameters.
  function check(fnamei) result(fnameo)
  !---------------------------------------------------------------------------------------------------------------------------------
  implicit none
  character(*), intent(IN):: fnamei  !< File name of check parameter.
  character(Nc)::            fnameo  !< File name of output grd file.
  integer(I4P)::             ui,uo   !< Units file.
  integer(I4P)::             Nb      !< Number of block.
  integer(I4P)::             b,i,j,k !< Counters.
  !---------------------------------------------------------------------------------------------------------------------------------

  !---------------------------------------------------------------------------------------------------------------------------------
  open(unit=Get_Unit(ui),file=trim(fnamei),form = 'FORMATTED')
  read(ui,*)fnameo
  open(unit=Get_Unit(uo),file=trim(fnameo),form = 'UNFORMATTED')
  read(ui,*)Nb ; write(uo)Nb
  do b=1,Nb
    read(ui,*)i,j,k ; write(uo)i,j,k
  enddo
  close(ui)
  close(uo)
  return
  !---------------------------------------------------------------------------------------------------------------------------------
  endfunction check
endprogram loadbalance
